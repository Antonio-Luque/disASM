
; File #0: C:\Users\Antonio\source\repos\disASM\Z80CodeFiles\disASM.z80asm

8000             0 1 ; **********************************************************************************************************************
8000             0 2 ; **  disASM                                                                                                          **
8000             0 3 ; **                                                                                                                  **
8000             0 4 ; **  Based on Disassembler support from Small Computer Monitor (SCM)                           by Stephen C Cousins  **
8000             0 5 ; **  https://smallcomputercentral.com/small-computer-monitor/small-computer-monitor-v1-0/                            **
8000             0 6 ; **                                                                                                                  **
8000             0 7 ; **  Adapted for ZX Spectrum disASM                                                                by Antonio Luque  **
8000             0 8 ; **********************************************************************************************************************
8000             0 11 START               ORG     $E100
E100             0 13 Main:
E100 21 48 07    0 14 ld      hl, Realloc_Addrs-START     ; HL points to relative address of Realloc_Addrs
E103 09          0 15 add     hl, bc                      ; Move HL to absolute address of reallocation addresses
E104             0 17 ; Avoid 'call Reallocation'

; File #1: C:\Users\Antonio\source\repos\disASM\Z80CodeFiles\Reallocation.z80asm

E104             1 1 ; **********************************************************************************************************************
E104             1 2 ; **  Reallocation                                                                        by HiSoft Devpac, (C) 1983  **
E104             1 3 ; **                                                                                                                  **
E104             1 4 ; **  This piece of code has been disassembled from MONS v4.1 and adapted for disASM by Antonio Luque                 **
E104             1 5 ; **********************************************************************************************************************
E104             1 8 ; Reallocate pointers and calls pointed to by the 'Realloc_X' tags
E104             1 9 ;   On entry: HL = address of reallocation addresses (Realloc_Addrs)
E104             1 10 ;             BC = address of program start
E104             1 11 ;   On exit:  BC IX IY I AF' BC' DE' HL' preserved
E104             1 12 Reallocation:
E104 5E          1 13 ld      e, (hl)                     ; DE = relative reallocation address
E105 23          1 14 inc     hl
E106 56          1 15 ld      d, (hl)
E107 23          1 16 inc     hl                          ; Move HL to next relative reallocation address
E108 7A          1 17 ld      a, d                        ; last address?
E109 B3          1 18 or      e
E10A 28 11       1 19 jr      z, Re_Entry                 ; yes, reallocation finished
E10C EB          1 21 ex      de, hl                      ; HL = relative reallocation address
E10D 09          1 22 add     hl, bc                      ; HL points to address parameter of the instr. at 'Realloc_X'
E10E D5          1 23 push    de                          ; Store next relative reallocation address
E10F E5          1 24 push    hl                          ; Store pointer to address parameter of the instruction
E110 5E          1 25 ld      e, (hl)                     ; Save the content of the address parameter in DE
E111 23          1 26 inc     hl
E112 56          1 27 ld      d, (hl)
E113 EB          1 28 ex      de, hl                      ; Calculate absolute address in HL
E114 09          1 29 add     hl, bc
E115 EB          1 30 ex      de, hl                      ; DE = absolute address parameter of the instruction
E116 E1          1 31 pop     hl                          ; Restore pointer to address parameter of the instruction
E117 73          1 32 ld      (hl), e                     ; Update address parameter of the instruction with calculated
E118 23          1 33 inc     hl                          ;   absolute address
E119 72          1 34 ld      (hl), d
E11A E1          1 35 pop     hl                          ; Restore next relative reallocation address
E11B 18 E7       1 36 jr      Reallocation                ; Repeat again
E11D             1 38 ; From this point on, all address parameters of the instructions pointed to by the 'Realloc_X' tags
E11D             1 39 ;  have been updated with the corresponding absolute address.
E11D             1 41 Re_Entry:
E11D             1 42 ; Put 'JP Init' at the start of program for the re-entry
E11D 3E C3       1 43 ld      a, $C3                      ; 'JP' opcode
E11F 32 00 00    1 44 Realloc_A           ld      ($0000), a                  ; Put it at program start
E122 21 28 00    1 45 Realloc_B           ld      hl, Init-START              ; HL points to Init
E125 22 01 00    1 46 Realloc_C           ld      ($0001), hl                 ; Put Init address as parameter of JP instruction

; File #0: C:\Users\Antonio\source\repos\disASM\Z80CodeFiles\disASM.z80asm

E128             0 20 ; Re-entry of program after first execution
E128             0 21 Init:
E128 21 C0 07    0 22 ld      hl, END-START               ; HL points to relative address of stack address
E12B 09          0 23 add     hl, bc                      ; Move HL to absolute address of stack addresses
E12C F9          0 24 ld      sp, hl                      ; Move stack at bottom of Realloc_Addrs
E12D CD 41 00    0 26 Realloc_1           call    InputAddresses-START        ; Input "from" and "to" addresses from keyboard
E130             0 28 ; Disassembly loop
E130             0 29 DisInstruction:
E130 C5          0 30 push    bc                          ; Store "to"+1 address
E131 D5          0 31 push    de                          ; Store string buffer address
E132 CD 65 02    0 33 Realloc_2           call    DisWrInstruction-START      ; Write fully disassembly instruction in buffer
E135 CD DE 00    0 34 Realloc_3           call    PrintDisassembly-START      ; Print buffer
E138 D1          0 36 pop     de                          ; Restore string buffer address
E139 C1          0 37 pop     bc                          ; Restore "to"+1 address
E13A             0 39 ;and     a                          ; reset carry flag
E13A ED 42       0 40 sbc     hl, bc                      ; check if reach "to"+1 address
E13C 09          0 41 add     hl, bc
E13D 38 F1       0 42 jr      c, DisInstruction           ; loop until reach "to"+1 address
E13F CF          0 44 rst     $08                         ; return to BASIC: "0 OK, "
E140 FF          0 45 DEFB    $FF
E141             0 48 ; Support routines and data

; File #2: C:\Users\Antonio\source\repos\disASM\Z80CodeFiles\IOSupport.z80asm

E141             2 1 ; **********************************************************************************************************************
E141             2 2 ; **  Input/Output support                                                                          by Antonio Luque  **
E141             2 3 ; **********************************************************************************************************************
E141             2 6 ; ROM routines and system variables
E141             2 7 CLS_LOWER           EQU     $0D6E                       ; Clear the lower part of the display
E141             2 8 CL_ALL              EQU     $0DAF                       ; Clear the whole display area
E141             2 9 CHAN_OPEN           EQU     $1601                       ; Open channel subroutine
E141             2 10 PR_STRING           EQU     $203C                       ; Print string
E141             2 11 LAST_K              EQU     $5C08                       ; Last key pressed
E141             2 13 ; Control characters
E141             2 14 CHR_LEFT            EQU     $08                         ; Move cursor backwards
E141             2 15 CHR_DELETE          EQU     $0C                         ; Delete
E141             2 16 CHR_FLASH           EQU     $12                         ; Flash attribute
E141             2 19 ; IOSupport: Input "from" and "to" addresses from keyboard
E141             2 20 ;  On entry: -
E141             2 21 ;  On exit:  HL = Start of instruction to be disassembled ("from")
E141             2 22 ;            BC = End of instrucction to be disassembled ("to"+1)
E141             2 23 ;            DE = Start of string buffer
E141             2 24 ;            IX IY I AF' preserved
E141             2 25 ; Adapted from MONS v4.1 by HiSoft Devpac, (C) 1983
E141             2 26 InputAddresses:
E141 CD 6E 0D    2 27 call    CLS_LOWER                   ; Clear the lower part of the display
E144 FD CB 30 5E 2 29 bit     3, (iy+48)                  ; Query CAPS LOCK flag (FLAGS2 system variable)
E148 F5          2 30 push    af                          ; Store flags to maintain status
E149 FD CB 30 DE 2 31 set     3, (iy+48)                  ; Set CAPS LOCK (FLAGS2 system variable)
E14D 11 3E 07    2 33 Realloc_4           ld      de, StrLabels-START         ; DE points to "from" string
E150 06 02       2 34 ld      b, 2                        ; Number of inputs: "from" and "to" (loop counter)
E152             2 35 Print_Label:
E152 C5          2 36 push    bc                          ; Store current number of inputs
E153 01 05 00    2 37 ld      bc, 5                       ; Length of string
E156 CD 3C 20    2 38 call    PR_STRING                   ; Print string
E159 D5          2 39 push    de                          ; Store next string pointer
E15A 0C          2 40 inc     c                           ; Set C = 0 (current number of nibbles)
E15B             2 41 Get_Address:
E15B 3E 12       2 42 ld      a, CHR_FLASH                ; Activate flash attribute
E15D D7          2 43 rst     $10
E15E 3E 01       2 44 ld      a, 1
E160 D7          2 45 rst     $10
E161 3E 43       2 46 ld      a, 'C'                      ; Print 'C3' cursor
E163 D7          2 47 rst     $10
E164 3E 12       2 48 ld      a, CHR_FLASH                ; Deactivate flash attribute
E166 D7          2 49 rst     $10
E167 AF          2 50 xor     a
E168 D7          2 51 rst     $10
E169 FD CB 01 AE 2 52 res     5, (iy+1)                   ; Set key pressed flag = off
E16D             2 53 Wait_Key:
E16D FD CB 01 6E 2 54 bit     5, (iy+1)                   ; Key pressed?
E171 28 FA       2 55 jr      z, Wait_Key                 ; No, repeat until key pressed
E173 3E 08       2 56 ld      a, CHR_LEFT                 ; Move cursor left
E175 D7          2 57 rst     $10
E176 3A 08 5C    2 58 ld      a, (LAST_K)                 ; Get ASCII code of key pressed
E179 FE 0C       2 59 cp      CHR_DELETE                  ; Is it Delete?
E17B 28 35       2 60 jr      z, Delete                   ; Yes, perform deleting of previous character
E17D FE 30       2 61 cp      '0'                         ; Is it < '0' ?
E17F 38 DA       2 62 jr      c, Get_Address              ; Yes, repeat key input
E181 FE 47       2 63 cp      'G'                         ; Is it >= 'g' ?
E183 30 D6       2 64 jr      nc, Get_Address             ; Yes, repeat key input
E185 FE 3A       2 65 cp      ':'                         ; Is it < ':' ?
E187 38 04       2 66 jr      c, Input_OK                 ; Yes, perform key input
E189 FE 41       2 67 cp      'A'                         ; Is it < 'a' ?
E18B 38 CE       2 68 jr      c, Get_Address              ; Yes, repeat key input
E18D             2 70 ; ASCII code is between '0' and '9' or between 'a' and 'f'
E18D             2 71 Input_OK:
E18D D7          2 72 rst     $10                         ; Print ASCII code
E18E 3A 08 5C    2 73 ld      a, (LAST_K)                 ; Get ASCII code of key pressed in A
E191 D6 30       2 74 sub     '0'                         ; Convert ASCII to decimal number range
E193 FE 0A       2 75 cp      10                          ; Is it in range 0..9 ?
E195 38 02       2 76 jr      c, High_Nibble              ; Yes, perform high nibble
E197 D6 07       2 77 sub     'A'-'0'-10                  ; No, convert to range A..F
E199             2 78 High_Nibble:
E199 0C          2 79 inc     c                           ; Increment current number of nibbles
E19A CB 41       2 80 bit     0, c                        ; Check if number of nibbles is odd or even 
E19C 28 05       2 81 jr      z, Low_Nibble               ; If odd, perform low nibble
E19E 87          2 82 add     a, a                        ; Multiply number by 16
E19F 87          2 83 add     a, a
E1A0 87          2 84 add     a, a
E1A1 87          2 85 add     a, a
E1A2 47          2 86 ld      b, a                        ; Save high nibble in B
E1A3             2 87 Low_Nibble:
E1A3 B0          2 88 or      b                           ; Bitwise OR with high nibble (get byte)
E1A4 47          2 89 ld      b, a                        ; Save byte in B
E1A5 79          2 90 ld      a, c                        ; Get current number of nibbles
E1A6 FE 04       2 91 cp      4                           ; Is it 4 ?
E1A8 28 1F       2 92 jr      z, Next_Address             ; Yes, prepare for next address
E1AA 1F          2 93 rra                                 ; Is it odd ?
E1AB 38 AE       2 94 jr      c, Get_Address              ; Yes, continue with next nibble
E1AD 60          2 95 ld      h, b                        ; Store high byte of address in H
E1AE 06 00       2 96 ld      b, 0                        ; Reset high nibble
E1B0 18 A9       2 97 jr      Get_Address                 ; Continue with next nibble
E1B2             2 98 ; Delete key pressed
E1B2             2 99 Delete:
E1B2 79          2 100 ld      a, c                        ; Get current number of nibbles
E1B3 B7          2 101 or      a                           ; Is it = 0 ?
E1B4 28 A5       2 102 jr      z, Get_Address              ; Yes, nothing to delete
E1B6 1F          2 103 rra                                 ; Is it odd ?
E1B7 38 04       2 104 jr      c, Cursor_Left              ; Yes, move cursor left
E1B9 7C          2 105 ld      a, h                        ; If even, recover previous byte from H
E1BA E6 F0       2 106 and     %11110000                   ;  and store high nibble in B
E1BC 47          2 107 ld      b, a
E1BD             2 108 Cursor_Left:
E1BD 0D          2 109 dec     c                           ; Decrement number of nibbles
E1BE 3E 20       2 110 ld      a, ' '                      ; Print space (delete character)
E1C0 D7          2 111 rst     $10
E1C1 3E 08       2 112 ld      a, CHR_LEFT                 ; Move cursor left two times
E1C3 D7          2 113 rst     $10
E1C4 3E 08       2 114 ld      a, CHR_LEFT
E1C6 D7          2 115 rst     $10
E1C7 18 92       2 116 jr      Get_Address                 ; Continue with next nibble
E1C9             2 117 ; Store "from" address and prepare input of "to" address
E1C9             2 118 Next_Address:
E1C9 68          2 119 ld      l, b                        ; Store low byte of address in L
E1CA D9          2 120 exx                                 ; Store address in HL'
E1CB D1          2 121 pop     de                          ; Restore next string pointer
E1CC C1          2 122 pop     bc                          ; Restore current number of inputs
E1CD 10 83       2 123 djnz    Print_Label                 ; Repeat for each address
E1CF             2 125 ; The "from" and "to" addresses are in HL and HL' respectively
E1CF D9          2 126 exx                                 ; HL = "to" address, HL' = "from" address
E1D0 E5          2 127 push    hl                          ; Store "to" address
E1D1 CD AF 0D    2 128 call    CL_ALL                      ; Clear display area
E1D4 D9          2 129 exx                                 ; HL = "from" address
E1D5 C1          2 130 pop     bc                          ; Restore "to" address in BC
E1D6 03          2 131 inc     bc                          ; Increment "to" address
E1D7             2 133 ; Maintain CAPS LOCK status
E1D7 F1          2 134 pop     af                          ; Restore flags
E1D8 C0          2 135 ret     nz                          ; If CAPS LOCK is set, return 
E1D9 FD CB 30 9E 2 136 res     3, (iy+48)                  ; Reset CAPS LOCK (FLAGS2 system variable)
E1DD C9          2 137 ret
E1DE             2 140 ; IOSupport: Print fully disassembly from string buffer
E1DE             2 141 ;  On entry: -
E1DE             2 142 ;  On exit:  HL IX IY I AF' BC' DE' HL' preserved
E1DE             2 143 PrintDisassembly:
E1DE E5          2 144 push    hl                          ; Store pointer to next instruction to be disassembled
E1DF 3E 02       2 146 ld      a, 2                        ; Set bottom line limit to print (top line = 24)
E1E1 FD BE 4F    2 147 cp      (iy+79)                     ; Compares with current line number (S_POSN+1 system varible)
E1E4 20 29       2 148 jr      nz, Print                   ; If limit not reached then print buffer
E1E6 3D          2 150 dec     a                           ; Open channel #1 (last two lines)
E1E7 CD 01 16    2 151 call    CHAN_OPEN
E1EA 11 39 07    2 152 Realloc_5           ld      de, StrMore-START           ; DE points to "more?" string
E1ED 01 05 00    2 153 ld      bc, 5                       ; BC = length of string
E1F0 CD 3C 20    2 154 call    PR_STRING                   ; Print string
E1F3 FD CB 01 AE 2 155 res     5, (iy+1)                   ; Set key pressed flag = off
E1F7             2 156 Wait_More:
E1F7 FD CB 01 6E 2 157 bit     5, (iy+1)                   ; Key pressed?
E1FB 28 FA       2 158 jr      z, Wait_More                ; No, repeat until key pressed
E1FD 3A 08 5C    2 159 ld      a, (LAST_K)                 ; Get ASCII code of key pressed
E200 FE 20       2 160 cp      ' '                         ; Is it space?
E202 28 1A       2 161 jr      z, Break                    ; Yes, return to BASIC
E204 FE 6E       2 162 cp      'n'                         ; Is it = 'n' ?
E206 28 14       2 163 jr      z, Stop                     ; Yes, return to BASIC
E208 FE 4E       2 164 cp      'N'                         ; Is it = 'N' ?
E20A 28 10       2 165 jr      z, Stop                     ; Yes, return to BASIC
E20C CD AF 0D    2 166 call    CL_ALL                      ; Clear display area
E20F             2 167 Print:
E20F 11 48 07    2 168 Realloc_6           ld      de, kStrBuffer-START        ; DE points to string buffer
E212 1A          2 169 ld      a, (de)                     ; Get string length
E213 13          2 170 inc     de                          ; Move DE to first character of the string
E214 06 00       2 171 ld      b, 0                        ; BC = length of the string
E216 4F          2 172 ld      c, a
E217 CD 3C 20    2 173 call    PR_STRING                   ; Print string
E21A E1          2 175 pop     hl                          ; Restore pointer to next instruction to be disassembled
E21B C9          2 176 ret
E21C             2 177 Stop:
E21C CF          2 178 rst     $08                         ; return to BASIC: "9 STOP statement, "
E21D 08          2 179 DEFB    $08
E21E             2 180 Break:
E21E CF          2 181 rst     $08                         ; return to BASIC: "L BREAK into program, "
E21F 14          2 182 DEFB    $14

; File #3: C:\Users\Antonio\source\repos\disASM\Z80CodeFiles\Strings.z80asm

E220             3 1 ; **********************************************************************************************************************
E220             3 2 ; **  String support                                                                            by Stephen C Cousins  **
E220             3 3 ; **                                                                                                                  **
E220             3 4 ; **  Adapted for ZX Spectrum disASM                                                                by Antonio Luque  **
E220             3 5 ; **********************************************************************************************************************
E220             3 8 ; String: Write hex word to string buffer
E220             3 9 ;   On entry: DE = Hex word
E220             3 10 ;   On exit:  B DE HL IX IY I AF' BC' DE' HL' preserved
E220             3 11 StrWrHexWord:
E220 7A          3 12 ld      a, d                        ; Get hi byte
E221 CD 25 01    3 13 Realloc_7           call    StrWrHexByte-START          ; Write as two hex digits
E224 7B          3 14 ld      a, e                        ; Get lo byte
E225             3 15 ; String: Write hex byte to string buffer
E225             3 16 ;   On entry: A = Hex byte
E225             3 17 ;   On exit:  B DE HL IX IY I AF' BC' DE' HL' preserved
E225             3 18 StrWrHexByte:
E225 4F          3 19 ld      c, a                        ; Save byte to convert
E226 1F          3 20 rra                                 ; Shift top nibble to
E227 1F          3 21 rra                                 ;  botom four bits..
E228 1F          3 22 rra
E229 1F          3 23 rra
E22A E6 0F       3 24 and     %00001111                   ; Mask off unwanted bits
E22C CD 32 01    3 25 Realloc_8           call    StrWrHexNibble-START        ; Write top nibble
E22F 79          3 26 ld      a, c                        ; Restore byte to convert
E230 E6 0F       3 27 and     %00001111                   ; Mask off unwanted bits
E232             3 28 ; String: Write hex nibble to string buffer
E232             3 29 ;   On entry: A = Hex nibble
E232             3 30 ;   On exit:  BC DE HL IX IY I AF' BC' DE' HL' preserved
E232             3 31 ; https://wikiti.brandonw.net/index.php?title=Z80_Optimization#DAA_trick
E232             3 32 StrWrHexNibble:
E232 FE 0A       3 33 cp      10                          ; if (nibble < 10) then (carry = on)
E234 3F          3 34 ccf                                 ; invert carry
E235 CE 30       3 35 adc     a, '0'                      ; A = nibble + ('0' or '1')
E237 27          3 36 daa                                 ; convert nibble to ASCII
E238             3 37 ; String: Write character
E238             3 38 ;   On entry: A = Character to write to string buffer
E238             3 39 ;   On exit:  BC DE HL IX IY I AF' BC' DE' HL' preserved
E238             3 40 ; The specified character is writted to the string buffer and a null
E238             3 41 ; terminator added.
E238             3 42 StrWrChar:
E238 E5          3 43 push    hl                          ; Store HL register
E239             3 44 iStrStart:
E239 21 00 00    3 45 ld      hl, $0000                   ; HL points to current empty position of the string
E23C 77          3 46 ld      (hl), a                     ; Store character at string position
E23D 23          3 47 inc     hl                          ; Move HL to next empty position
E23E 22 3A 01    3 48 Realloc_9           ld      (iStrStart-START+1), hl     ; Update pointer to current empty position
E241 E1          3 49 pop     hl                          ; Restore HL register
E242 C9          3 50 ret

; File #4: C:\Users\Antonio\source\repos\disASM\Z80CodeFiles\DisSupport.z80asm

E243             4 1 ; **********************************************************************************************************************
E243             4 2 ; **  Disassembler support                                                                      by Stephen C Cousins  **
E243             4 3 ; **                                                                                                                  **
E243             4 4 ; **  Adapted for ZX Spectrum disASM                                                                by Antonio Luque  **
E243             4 5 ; **********************************************************************************************************************
E243             4 8 kDisBrack:          EQU     5                           ; Bracket flag
E243             4 9 kDisImmed:          EQU     4                           ; Immediate value flag
E243             4 10 kDisWord:           EQU     3                           ; Immediate value is word (not byte) flag
E243             4 11 kDisLength:         EQU     2                           ; Substite two characters (not one) flag
E243             4 12 kDisMask:           EQU     3                           ; Mask type 0=0x07,1=0x18,2=0x30,3=0x38
E243             4 13 kDisSubsL:          EQU     $0D                         ; Last operand substitution string
E243             4 14 kDisBracHL:         EQU     $15                         ; Bracketed HL
E243             4 15 kDisHL:             EQU     $18                         ; Operation string 'HL'
E243             4 16 kDisJR:             EQU     $1B                         ; Operation string 'JR'
E243             4 17 kDisDJNZ:           EQU     $1C                         ; Operation string 'DJNZ'
E243             4 18 kDisJP:             EQU     $1E                         ; Operation string 'JP'
E243             4 19 kDisH               EQU     $6E                         ; Operation string 'H'
E243             4 20 kDisL               EQU     $71                         ; Operation string 'L'
E243             4 21 kDisOpMask:         EQU     $3F                         ; Operand 1 mask to exclude pre-code bits
E243             4 23 ; Control characters
E243             4 24 CHR_ENTER           EQU     $0D
E243             4 26 ; Disassembler: Write character to string buffer
E243             4 27 ;   On entry: A = Character to write
E243             4 28 ;   On exit:  BC DE HL IX IY I AF' BC' DE' HL' preserved
E243             4 29 ; This version of write character removes bit 7 (the new string flag)
E243             4 30 ; and replaces "-" with "(HL)"
E243             4 31 DisWrChar:
E243 E6 7F       4 32 and     %01111111                   ; Mask off bit 7 (string start bit)
E245 FE 2D       4 33 cp      '-'                         ; Code for "(HL)" ?
E247 20 EF       4 34 jr      nz, StrWrChar               ; No, print character
E249 3E 15       4 36 ld      a, kDisBracHL               ; String number for "(HL)"
E24B             4 37 ; Write disassembler string
E24B             4 38 ;   On entry: A = Disassembler data string number
E24B             4 39 ;             B = Offset to current opcode from start of instruction
E24B             4 40 ;             IY = Start address for current instruction
E24B             4 41 ;   On exit:  C DE HL IX IY I AF' BC' DE' HL' preserved
E24B             4 42 ;             B is incremented if (IX/IY+d) is substituted
E24B             4 43 ; This version of write string removes bit 7 (the new string flag)
E24B             4 44 ; If iDisTmp1 (the current index instruction opcode) is 0xDD or 0xFD, 
E24B             4 45 ; is not zero then strings are replaced: 
E24B             4 46 ;   HL is replaced with IX or IY
E24B             4 47 ;   (HL) is replaced with (IX + d) or (IY + d) except for JP instruction
E24B             4 48 ;   where is is just replaced by (IX) or (IY)
E24B             4 49 DisWrString:
E24B E5          4 50 push    hl                          ; Store HL register
E24C 6F          4 52 ld      l, a                        ; Store string number
E24D FE 6E       4 53 cp      kDisH                       ; String = H ?
E24F 28 0C       4 54 jr      z, Subs                     ; Yes, so go do substitution
E251 FE 71       4 55 cp      kDisL                       ; String = L ?
E253 28 08       4 56 jr      z, Subs                     ; Yes, so go do substitution
E255 FE 15       4 57 cp      kDisBracHL                  ; String = (HL) ?
E257 28 04       4 58 jr      z, Subs                     ; Yes, so go do substitution
E259 FE 18       4 59 cp      kDisHL                      ; String = HL ?
E25B 20 0B       4 60 jr      nz, GotString               ; No, so just write the string
E25D             4 61 ; Substitute IX/IY in HL string or (IX/IY+d) in (HL) string
E25D             4 62 Subs:
E25D             4 63 iDisIndex:
E25D 3E 00       4 64 ld      a, $00                      ; Get index instruction opcode
E25F B7          4 65 or      a                           ; Index instruction?
E260 28 06       4 66 jr      z, GotString                ; No, so skip substitutions
E262 2C          4 67 inc     l                           ; Increment to IX string number
E263 FE DD       4 68 cp      $DD                         ; IX instruction?
E265 28 01       4 69 jr      z, GotString                ; Yes, so go write it
E267 2C          4 70 inc     l                           ; Increment to IY string
E268             4 71 GotString:
E268 7D          4 72 ld      a, l                        ; Get string number
E269 CD 6E 03    4 73 Realloc_10          call    FindStringInList-START      ; Find start of string A
E26C             4 75 ; HL now points to disassembler string
E26C             4 76 Char:
E26C 7E          4 77 ld      a, (hl)                     ; Get character from string
E26D E6 7F       4 78 and     %01111111                   ; Mask off string start bit
E26F FE 2B       4 79 cp      '+'                         ; Is it a '+' sign (displacement) ?
E271 28 05       4 80 jr      z, Plus                     ; No, so skip to next character
E273 CD 38 01    4 81 Realloc_11          call    StrWrChar-START             ; Write character
E276 18 30       4 82 jr      Next                        ; No, so skip to next character
E278             4 83 ; Encountered a plus sign so expecting to show a displacement
E278             4 84 Plus:
E278             4 85 iDisOpStr:
E278 3E 00       4 86 ld      a, $00                      ; Get instruction string
E27A FE 1E       4 87 cp      kDisJP                      ; JP instruction?
E27C 20 07       4 88 jr      nz, Displace                ; No, so go show displacement
E27E 3E 29       4 89 ld      a, ')'                      ; Yes, so just terminate with ')'
E280 CD 38 01    4 90 Realloc_12          call    StrWrChar-START             ; Write close bracket character
E283 18 28       4 91 jr      Exit
E285             4 92 ; Show displacement in (IX+...) and (IY+...) instructions
E285             4 93 Displace:
E285 FD 7E 02    4 94 ld      a, (iy+2)                   ; Get index instruction displacement
E288 FE 80       4 95 cp      $80                         ; Is it signed?
E28A 30 05       4 96 jr      nc, Signed                  ; Yes, negate index instruction displacement
E28C 08          4 97 ex      af, af'                     ; Store unsigned index instruction displacement
E28D 3E 2B       4 98 ld      a, '+'                      ; set '+' for unsigned
E28F 18 05       4 99 jr      Convert
E291             4 100 Signed:
E291 ED 44       4 101 neg                                 ; Negate index instruction displacement
E293 08          4 102 ex      af, af'                     ; Store signed index instruction displacement
E294 3E 2D       4 103 ld      a, '-'                      ; set '-' for signed
E296             4 104 Convert:
E296 CD 38 01    4 105 Realloc_13          call    StrWrChar-START             ; Write plus or minus
E299 3E 24       4 106 ld      a, '$'                      ; Write '$'
E29B CD 38 01    4 107 Realloc_14          call    StrWrChar-START
E29E 08          4 108 ex      af, af'                     ; Restore index instruction displacement
E29F CD 25 01    4 109 Realloc_15          call    StrWrHexByte-START          ; Write index instruction displacement
E2A2 3E 29       4 110 ld      a, ')'
E2A4 CD 38 01    4 111 Realloc_16          call    StrWrChar-START             ; Write close bracket character
E2A7 04          4 112 inc     b                           ; Increment opcode offset
E2A8             4 113 ; Consider next character in disassembler string
E2A8             4 114 Next:
E2A8 23          4 115 inc     hl                          ; Point to next character
E2A9 CB 7E       4 116 bit     7, (hl)                     ; Start of new string?
E2AB 28 BF       4 117 jr      z, Char                     ; No, so go get next character
E2AD             4 118 Exit:
E2AD E1          4 119 pop     hl                          ; Restore HL register
E2AE C9          4 120 ret
E2AF             4 123 ; Disassembler: Write operand to buffer
E2AF             4 124 ;   On entry: A = Operand string number
E2AF             4 125 ;             B = Offset to opcode from start of instruction
E2AF             4 126 ;             C = Primary op-code
E2AF             4 127 ;             IY = Start address of instruction
E2AF             4 128 ;   On exit:  A = Unspecified
E2AF             4 129 ;             B = Updated offset to opcode from start of instruction
E2AF             4 130 ;             C = Not specified
E2AF             4 131 ;             DE HL IX IY I AF' BC' DE' HL' preserved
E2AF             4 132 DisWrOperand:
E2AF E6 3F       4 133 and     kDisOpMask                  ; Mask off flag bits
E2B1 FE 0E       4 134 cp      kDisSubsL+1                 ; Substitution operand string?
E2B3 30 96       4 135 jr      nc, DisWrString             ; No, so just write string
E2B5 E5          4 137 push    hl                          ; Store registers
E2B6 D5          4 138 push    de
E2B7             4 140 ; Calculate operand table location for this operand and get details
E2B7 21 19 07    4 141 Realloc_17          ld      hl, DisOperandTable-START-2 ; HL points to DisOperandTable address (-2)
E2BA 87          4 142 add     a, a                        ; Two bytes per entry
E2BB 16 00       4 143 ld      d, 0                        ; Move HL to operand address
E2BD 5F          4 144 ld      e, a
E2BE 19          4 145 add     hl, de
E2BF 5E          4 146 ld      e, (hl)                     ; Get substitution string number
E2C0 23          4 147 inc     hl                          ; Point to BIILMM bits
E2C1 56          4 148 ld      d, (hl)                     ; Get BIILMM function bits
E2C2 D5          4 150 push    de                          ; So we can use E for scratch reg
E2C3             4 151 ; Process this operand as detailed in DE, left bracket?
E2C3 CB 6A       4 152 bit     kDisBrack, d                ; Bracket flagged?
E2C5 28 05       4 153 jr      z, NoBracL                  ; No, so skip
E2C7 3E 28       4 154 ld      a, '('                      ; Get left bracket character
E2C9 CD 38 01    4 155 Realloc_18          call    StrWrChar-START             ; Print left bracket
E2CC             4 156 NoBracL:
E2CC             4 157 ; Process this operand as detailed in DE, immediate value?
E2CC CB 62       4 158 bit     kDisImmed, d                ; Immediate value flagged?
E2CE 28 1E       4 159 jr      z, NoImmedia                ; No, so skip
E2D0 3E 24       4 160 ld      a, '$'
E2D2 CD 38 01    4 161 Realloc_19          call    StrWrChar-START             ; Write '$'
E2D5 04          4 162 inc     b                           ; Increment offset to lo byte
E2D6 78          4 163 ld      a, b                        ; Offset to instruction byte
E2D7 CD 5F 03    4 164 Realloc_20          call    DisGetOpcode-START          ; Get lo byte of immediate value
E2DA 32 3C 03    4 165 Realloc_21          ld      (iDisImmed-START+1), a      ; Store lo byte of immediate value
E2DD 5F          4 166 ld      e, a                        ; Store lo byte of immediate value
E2DE CB 5A       4 167 bit     kDisWord, d                 ; Immediate value is a word?
E2E0 28 08       4 168 jr      z, ImmedLo                  ; No, so skip
E2E2 04          4 169 inc     b                           ; Increment offset to hi byte
E2E3 78          4 170 ld      a, b                        ; Offset to instruction byte
E2E4 CD 5F 03    4 171 Realloc_22          call    DisGetOpcode-START          ; Get hi byte of immediate value
E2E7 CD 25 01    4 172 Realloc_23          call    StrWrHexByte-START          ; Print hi byte of immediate value
E2EA             4 173 ImmedLo:
E2EA 7B          4 174 ld      a, e                        ; Restore lo byte of immediate value
E2EB CD 25 01    4 175 Realloc_24          call    StrWrHexByte-START          ; Print lo byte of immediate value
E2EE             4 176 NoImmedia:
E2EE             4 177 ; Process this operand as detailed in DE, right bracket?
E2EE CB 6A       4 178 bit     kDisBrack, d                ; Bracket flagged?
E2F0 28 05       4 179 jr      z, NoBracR                  ; No, so skip
E2F2 3E 29       4 180 ld      a, ')'                      ; Get right bracket character
E2F4 CD 38 01    4 181 Realloc_25          call    StrWrChar-START             ; Print right bracket
E2F7             4 182 NoBracR:
E2F7             4 183 ; Process this operand as detailed in DE, substitution string?
E2F7 D1          4 184 pop     de                          ; Restore details
E2F8 7B          4 186 ld      a, e                        ; Get substitution string number
E2F9 B7          4 187 or      a                           ; String specified?
E2FA 28 66       4 188 jr      z, SubEnd                   ; No, so skip
E2FC 7A          4 189 ld      a, d                        ; Get BIILMM function bits
E2FD E6 03       4 190 and     kDisMask                    ; Separate mask type bits
E2FF 21 35 07    4 191 Realloc_26          ld      hl, DisMaskTable-START      ; Point to table of mask bits
E302 85          4 192 add     a, l                        ; Add to start of table
E303 6F          4 193 ld      l, a                        ; Store updated lo byte
E304 30 01       4 194 jr      nc, NoOFlow                 ; Skip if no overflow
E306 24          4 195 inc     h                           ; Overflow so increment hi byte
E307             4 196 NoOFlow:
E307 7E          4 197 ld      a, (hl)                     ; Get bit mask
E308 A1          4 198 and     c                           ; Mask primary opcode
E309 4F          4 199 ld      c, a                        ; Store masked primary opcode
E30A 7E          4 200 ld      a, (hl)                     ; Get bit mask
E30B             4 201 ; Now shift primary opcode (masked) to right the number of
E30B             4 202 ; times it takes to shift mask byte right before bit 1 is set
E30B             4 203 SubsShift:
E30B CB 3F       4 204 srl     a                           ; Shift mask right
E30D 38 04       4 205 jr      c, DoneShift                ; Bit 1 was set so we're done
E30F CB 39       4 206 srl     c                           ; Shift primary opcode (masked) right
E311 18 F8       4 207 jr      SubsShift                   ; Go repeat..
E313             4 208 DoneShift:
E313 CB 52       4 209 bit     kDisLength, d               ; Length bit flagged?
E315 28 02       4 210 jr      z, Single                   ; No, so skip
E317 CB 21       4 211 sla     c                           ; Double value for two bytes
E319             4 212 ; C is now the offset into the substitute string
E319             4 213 Single:
E319 7B          4 214 ld      a, e                        ; Substitute string number
E31A 21 7C 03    4 215 Realloc_27          ld      hl, DisString-START         ; Start of string list
E31D CD 6E 03    4 216 Realloc_28          call    FindStringInList-START      ; Get start of string (=HL)
E320 79          4 217 ld      a, c                        ; Offset into string
E321 85          4 218 add     a, l                        ; Add to start of string
E322 6F          4 219 ld      l, a                        ; Store updated lo byte
E323 30 01       4 220 jr      nc, NoOver                  ; Skip if no overflow
E325 24          4 221 inc     h                           ; Overflow so increment hi byte
E326             4 222 NoOver:
E326 7E          4 223 ld      a, (hl)                     ; Get substitute character
E327 4F          4 224 ld      c, a                        ; Save it for further use
E328 FE 2A       4 225 cp      '*'                         ; Code for 2 byte HL/IX/IY string
E32A 3E 18       4 226 ld      a, kDisHL                   ; Set operation string 'HL'
E32C 28 20       4 227 jr      z, Substitute               ; If 2 byte, go to substitutions
E32E             4 228 iDisOpcode:
E32E 3E 00       4 229 ld      a, $00                      ; Get primary opcode
E330             4 230 ; Check undocumented opcodes related to IXH, IXL, IYH and IYL (by Antonio Luque)
E330 FE 74       4 231 cp      $74                         ; opcode = "ld (ix/iy +d),h" ?
E332 28 1F       4 232 jr      z, NotStar                  ; Yes, skip
E334 FE 75       4 233 cp      $75                         ; opcode = "ld (ix/iy +d),l" ?
E336 28 1B       4 234 jr      z, NotStar                  ; Yes, skip
E338 FE 66       4 235 cp      $66                         ; opcode = "ld h,(ix/iy +d)" ?
E33A 28 17       4 236 jr      z, NotStar                  ; Yes, skip
E33C FE 6E       4 237 cp      $6E                         ; opcode = "ld l,(ix/iy +d)" ?
E33E 28 13       4 238 jr      z, NotStar                  ; Yes, skip
E340 79          4 239 ld      a, c                        ; Retreive substitute character
E341 FE 48       4 240 cp      'H'                         ; Is it 'H' ?
E343 3E 6E       4 241 ld      a, kDisH                    ; Set operation string 'H' 
E345 28 07       4 242 jr      z, Substitute               ; If 'H', go to substitutions
E347 79          4 243 ld      a, c                        ; Retreive substitute character
E348 FE 4C       4 244 cp      'L'                         ; Is it 'L' ?
E34A 3E 71       4 245 ld      a, kDisL                    ; Set operation string 'L' 
E34C 20 05       4 246 jr      nz, NotStar                 ; If Not 'L', skip
E34E             4 247 Substitute:
E34E CD 4B 01    4 248 Realloc_29          call    DisWrString-START           ; Print string with substitutions
E351 18 0F       4 249 jr      SubEnd                      ; exit
E353             4 250 NotStar:
E353 79          4 251 ld      a, c                        ; Retreive substitute character 
E354 CD 43 01    4 252 Realloc_30          call    DisWrChar-START             ; Print character with filters
E357 CB 52       4 253 bit     kDisLength, d               ; Length bit flagged?
E359 28 07       4 254 jr      z, SubEnd                   ; No, so skip
E35B 23          4 255 inc     hl                          ; Point to second substitute character
E35C 7E          4 256 ld      a, (hl)                     ; Get substitute character
E35D FE 2E       4 257 cp      '.'                         ; Do not print '.' character
E35F C4 43 01    4 258 Realloc_31          call    nz, DisWrChar-START         ; Print character with filters
E362             4 259 SubEnd:
E362 D1          4 260 pop     de                          ; Restore registers
E363 E1          4 261 pop     hl
E364 C9          4 262 ret
E365             4 265 ; Disassembler: Write full disassembly to string buffer
E365             4 266 ;   On entry: HL = Start of instruction to be disassembled
E365             4 267 ;             DE = String buffer address
E365             4 268 ;   On exit:  Address, opcodes and mnemonic in current string buffer
E365             4 269 ;             iDisIndex variable used
E365             4 270 ;             A = Length of instruction in bytes
E365             4 271 ;             HL = Start address of next instruction
E365             4 272 ;             IY I AF' BC' DE' HL' preserved
E365             4 273 DisWrInstruction:
E365 E5          4 274 push    hl                          ; Store start of instruction to be disassembled
E366             4 276 ; Fill string buffer for address and opcodes with spaces
E366 06 10       4 277 ld      b, 16                       ; B = buffer length (loop counter)
E368 13          4 278 inc     de                          ; Move DE to string buffer
E369 3E 20       4 279 ld      a, ' '                      ; Set space character
E36B             4 280 SpcLoop
E36B 12          4 281 ld      (de), a                     ; Put a space on the string buffer
E36C 13          4 282 inc     de                          ; Move DE to next position of the string buffer
E36D 10 FC       4 283 djnz    SpcLoop                     ; Loop until fill all buffer positions
E36F DD 21 F0 04 4 285 Realloc_32          ld      ix, DisInst-START           ; Start of instruction table
E373 ED 53 3A 01 4 286 Realloc_33          ld      (iStrStart-START+1), de     ; Initialise string for mnemonic
E377 CD A2 02    4 287 Realloc_34          call    DisWrMnemonic-START         ; Disassembly Mnemonic pointed by HL
E37A             4 289 ; Add disassembly address and opcodes
E37A 47          4 290 ld      b, a                        ; B = intruction length (loop counter)
E37B 11 48 07    4 292 Realloc_35          ld      de, kStrBuffer-START        ; DE points to the string for opcodes
E37E 2A 3A 01    4 293 Realloc_36          ld      hl, (iStrStart-START+1)     ; HL points to last character+1 of string for Nnemonic
E381             4 294 ;and     a                          ; Reset carry
E381 ED 52       4 295 sbc     hl, de                      ; Calculate length of total string (+1)
E383 EB          4 296 ex      de, hl                      ; E = length of total string (+1), move HL to string for opcodes
E384 73          4 297 ld      (hl), e                     ; Save length at begin of string
E385 35          4 298 dec     (hl)                        ; Adjust string length
E386 23          4 299 inc     hl                          ; Move DE to the first character of the string
E387 22 3A 01    4 300 Realloc_37          ld      (iStrStart-START+1), hl     ; Initialise string for opcodes
E38A E1          4 302 pop     hl                          ; Restore current instruction address
E38B 54          4 304 ld      d, h                        ; Get start of instruction..
E38C 5D          4 305 ld      e, l
E38D CD 20 01    4 306 Realloc_38          call    StrWrHexWord-START          ; Write start address of this line
E390 3E 3A       4 307 ld      a, ':'
E392 CD 38 01    4 308 Realloc_39          call    StrWrChar-START             ; Write colon
E395 3E 20       4 309 ld      a, ' '
E397 CD 38 01    4 310 Realloc_40          call    StrWrChar-START             ; Write space
E39A             4 312 Opcode:
E39A 7E          4 313 ld      a, (hl)                     ; Get instruction opcode
E39B CD 25 01    4 314 Realloc_41          call    StrWrHexByte-START          ; Write as hex byte
E39E 23          4 315 inc     hl                          ; Point to next byte 
E39F 10 F9       4 316 djnz    Opcode                      ; Loop until all hex bytes written
E3A1 C9          4 317 ret
E3A2             4 320 ; Disassembler: Write mnemonic only to string buffer
E3A2             4 321 ;   On entry: HL = Start of instruction to be disassembled
E3A2             4 322 ;   On exit:  Mnemonic is written to current string buffer
E3A2             4 323 ;             iDisIndex variable used
E3A2             4 324 ;             A = Length of instruction in bytes
E3A2             4 325 ;             IY I AF' BC' DE' HL' preserved
E3A2             4 326 DisWrMnemonic:
E3A2 F3          4 327 di                                  ; Disable interrupts to prevent use of IY register
E3A3 FD E5       4 328 push    iy                          ; Store system variables pointer
E3A5             4 330 ; Prepare to disassemble 
E3A5 E5          4 331 push    hl                          ; Copy start address of instruction
E3A6 FD E1       4 332 pop     iy                          ;  to IY
E3A8 AF          4 334 xor     a
E3A9 21 5E 01    4 335 Realloc_42          ld      hl, iDisIndex-START+1       ; Clear index instruction opcode
E3AC 77          4 336 ld      (hl), a
E3AD 47          4 337 ld      b, a                        ; Offset to instruction's primary opcode
E3AE 5F          4 338 ld      e, a                        ; Clear prefix for extended instructions
E3AF FD 7E 00    4 339 ld      a, (iy+0)                   ; Instruction's primary opcode 
E3B2             4 341 ; Check for index register instruction (IX or IY)
E3B2 FE DD       4 342 cp      $DD                         ; IX instruction?
E3B4 28 04       4 343 jr      z, Index                    ; Yes, so skip
E3B6 FE FD       4 344 cp      $FD                         ; IY instruction?
E3B8 20 05       4 345 jr      nz, NotIndex                ; No, so skip
E3BA             4 346 Index:
E3BA 77          4 347 ld      (hl), a                     ; Store index instruction opcode
E3BB 04          4 348 inc     b                           ; Increment offset to primary opcode
E3BC FD 7E 01    4 349 ld      a, (iy+1)                   ; Get next opcode byte
E3BF             4 350 NotIndex:
E3BF             4 351 ; Check for extended instruction
E3BF FE CB       4 352 cp      $CB                         ; Extended instruction?
E3C1 28 04       4 353 jr      z, Extend                   ; Yes, so skip
E3C3 FE ED       4 354 cp      $ED                         ; Extended instruction?
E3C5 20 0B       4 355 jr      nz, NotExtend               ; No, so skip
E3C7             4 356 Extend:
E3C7 5F          4 357 ld      e, a                        ; Store prefix for extended instructions
E3C8 04          4 358 inc     b                           ; Increment offset to primary opcode
E3C9 7E          4 359 ld      a, (hl)                     ; Get index instruction opcode
E3CA B7          4 360 or      a                           ; Is this an index instruction?
E3CB 78          4 361 ld      a, b                        ; Prepare to read primary opcode
E3CC 28 01       4 362 jr      z, ExNoIndx                 ; No, so skip
E3CE 3C          4 363 inc     a                           ; Yes, skip index displacement byte
E3CF             4 364 ExNoIndx:
E3CF CD 5F 03    4 365 Realloc_43          call    DisGetOpcode-START
E3D2             4 366 NotExtend:
E3D2 57          4 367 ld      d, a                        ; Remember instruction's primary opcode
E3D3 32 2F 02    4 368 Realloc_44          ld      (iDisOpcode-START+1), a     ; Store primary opcode
E3D6             4 370 ; Locate instruction table entry for current instruction
E3D6             4 371 ; BASIC: (i And iMask(n)) = (iValue(n) And iMask(n)) ?
E3D6             4 372 Table:
E3D6 DD 7E 00    4 373 ld      a, (ix+0)                   ; Get opcode value from table
E3D9 DD A6 01    4 374 and     (ix+1)                      ; AND with opcode mask from table
E3DC 4F          4 375 ld      c, a                        ; Store Value AND Mask
E3DD DD 7E 01    4 376 ld      a, (ix+1)                   ; Get opcode mask from table
E3E0 A2          4 377 and     d                           ; AND with instruction being disassembled
E3E1 B9          4 378 cp      c                           ; Is this the correct table entry?
E3E2 20 14       4 379 jr      nz, NotFound                ; No, so this is not the correct table
E3E4             4 380 ; BASIC: ... AND (p = iPrecode(n)) ?
E3E4 AF          4 381 xor     a                           ; Default precode for comparison = 0x00
E3E5 DD CB 03 7E 4 382 bit     7, (ix+3)                   ; Precode (index or extended)?
E3E9 28 0A       4 383 jr      z, GotPrCode                ; No, so skip
E3EB 3E CB       4 384 ld      a, $CB                      ; Default precode for comparison = 0xCB
E3ED DD CB 03 76 4 385 bit     6, (ix+3)                   ; Precode = 0xED?
E3F1 28 02       4 386 jr      z, GotPrCode                ; No, so skip
E3F3 3E ED       4 387 ld      a, $ED                      ; Yes, so precode for comparison = 0xED
E3F5             4 388 GotPrCode:
E3F5 BB          4 389 cp      e                           ; Compare table precode with instruction
E3F6 28 09       4 390 jr      z, Found                    ; Yes, so this is the correct table
E3F8             4 391 NotFound:
E3F8 C5          4 392 push    bc                          ; Preserve BC
E3F9 01 05 00    4 393 ld      bc, 5                       ; No, so try next table entry
E3FC DD 09       4 394 add     ix, bc                      ; Point to next table entry
E3FE C1          4 395 pop     bc                          ; Restore BC
E3FF 18 D5       4 396 jr      Table
E401             4 398 ; We now have the correct instruction table entry (pointer to by IX)
E401             4 399 ; BASIC: (p = iPrecode(n)) And (i And iMask(n)) = (iValue(n) And iMask(n))
E401             4 400 Found:
E401 DD 7E 02    4 401 ld      a, (ix+2)                   ; Get operation string number
E404 21 79 01    4 402 Realloc_45          ld      hl, iDisOpStr-START+1       ; Store operation string number
E407 77          4 403 ld      (hl), a
E408 CD 4B 01    4 404 Realloc_46          call    DisWrString-START           ; Write operation string
E40B 3E 20       4 406 ld      a, ' '                      ; Write space
E40D CD 38 01    4 407 Realloc_47          call    StrWrChar-START
E410             4 409 ; BASIC: Operand sString(iOperand1(n)), t
E410 DD 7E 03    4 410 ld      a, (ix+3)                   ; Get operand #1 string number
E413 4A          4 411 ld      c, d                        ; Get primary opcode value
E414 CD AF 01    4 412 Realloc_48          call    DisWrOperand-START
E417             4 414 ; BASIC: Operand sString(iOperand2(n)), t
E417 DD 7E 04    4 415 ld      a, (ix+4)                   ; Get operand #2 string number
E41A 3D          4 416 dec     a                           ; Is is 1? (null string)
E41B 28 0C       4 417 jr      z, NoOp2                    ; Yes, so skip this operand
E41D 3E 2C       4 419 ld      a, ','                      ; Get comma character
E41F CD 38 01    4 420 Realloc_49          call    StrWrChar-START             ; Write comma to string
E422 DD 7E 04    4 422 ld      a, (ix+4)                   ; Get operand #2 string number
E425 4A          4 423 ld      c, d                        ; Get primary opcode value
E426 CD AF 01    4 424 Realloc_50          call    DisWrOperand-START
E429             4 425 NoOp2:
E429             4 426 ; If relative jump show absolute address in brackets
E429 7E          4 427 ld      a, (hl)                     ; Get operation string number
E42A FE 1B       4 428 cp      kDisJR                      ; JR instruction?
E42C 28 04       4 429 jr      z, Rel                      ; Yes, so skip
E42E FE 1C       4 430 cp      kDisDJNZ                    ; DJNZ instruction?
E430 20 22       4 431 jr      nz, NotRel                  ; No so skip
E432             4 432 Rel:
E432 2A 3A 01    4 433 Realloc_51          ld      hl, (iStrStart+1-START)     ; An ugly way to only show absolute address
E435 2B          4 434 dec     hl                          ;  (by Antonio Luque)
E436 2B          4 435 dec     hl
E437 2B          4 436 dec     hl
E438 22 3A 01    4 437 Realloc_52          ld      (iStrStart-START+1), hl
E43B             4 438 iDisImmed:
E43B 3E 00       4 439 ld      a, $00                      ; Get immediate value from instruction
E43D 5F          4 440 ld      e, a                        ; Get displacement lo (signed byte)
E43E 16 00       4 441 ld      d, 0                        ; Default to hi byte = zero
E440 17          4 442 rla                                 ; Displacement negative?
E441 30 01       4 443 jr      nc, JRadd                   ; No, so skip
E443 15          4 444 dec     d                           ; Yes, so set hi byte to 0xFF
E444             4 445 JRadd:
E444 FD E5       4 446 push    iy                          ; Push address of instruction
E446 E1          4 447 pop     hl                          ; POP address of instruction
E447 23          4 448 inc     hl                          ; Increment to
E448 23          4 449 inc     hl                          ;  end of the JR/DJNZ instruction
E449 19          4 450 add     hl, de                      ; Add signed 16-bit displacement
E44A 54          4 451 ld      d, h                        ; Get destination address hi byte
E44B 5D          4 452 ld      e, l                        ; Get destination address lo byte
E44C 3E 24       4 454 ld      a, '$'
E44E CD 38 01    4 455 Realloc_53          call    StrWrChar-START             ; Write '$'
E451 CD 20 01    4 456 Realloc_54          call    StrWrHexWord-START          ; Write hex word to string
E454             4 458 NotRel:
E454             4 459 ; Finish building mnemonic string
E454 3E 0D       4 460 ld      a, CHR_ENTER
E456 CD 38 01    4 461 Realloc_55          call    StrWrChar-START
E459 78          4 463 ld      a, b                        ; Get offset into instruction
E45A 3C          4 464 inc     a                           ; Increment to give instruction length
E45B FD E1       4 466 pop     iy                          ; Restore system variables pointer
E45D FB          4 467 ei                                  ; Enable interrupts
E45E C9          4 468 ret
E45F             4 471 ; Disassembler: Get instruction opcode
E45F             4 472 ;   On entry: A = Offset from start of instruction
E45F             4 473 ;             IY = Start of instruction
E45F             4 474 ;   On exit:  A = Opcode
E45F             4 475 ;             BC DE HL IX IY I AF' BC' DE' HL' preserved
E45F             4 476 DisGetOpcode:
E45F C5          4 477 push    bc                          ; Store registers
E460 FD E5       4 478 push    iy
E462 4F          4 479 ld      c, a                        ; Offset from start of instruction
E463 06 00       4 480 ld      b, 0                        ; Clear hi byte ready for addition
E465 FD 09       4 481 add     iy, bc                      ; Calculate location of opcode
E467 FD 7E 00    4 482 ld      a, (iy+0)                   ; Get opcode from memory
E46A FD E1       4 483 pop     iy                          ; Restore registers
E46C C1          4 484 pop     bc
E46D C9          4 485 ret
E46E             4 487 ; Disassembler: How it works...
E46E             4 488 ; Solution is to use data table to define functions for each operand (see below)
E46E             4 489 ; Decoding table: where the table entry is determined by the operand string number
E46E             4 490 ; String numbers 0 to 12:
E46E             4 491 ;   If bracket flagged print "("
E46E             4 492 ;   If immediate byte flagged print hex byte at PC+Offset+1, Offset += 1
E46E             4 493 ;   If immediate word flagged print word byte at PC+Offset+1 and PC+Offset+2, Offset += 2
E46E             4 494 ;   If bracket flagged print ")"
E46E             4 495 ;   If substitution string specified: (non-zero value)
E46E             4 496 ;     n = opcode and SubsMask
E46E             4 497 ;     n = n >> x, where x is the number of right shifts of the mask til bit 0 is a 1
E46E             4 498 ;     If subsLen is 2 then n = n << 1
E46E             4 499 ;     c =  character at (start of Substitution String + n + 0)
E46E             4 500 ;     if = "-" then print "(HL)" else print character c
E46E             4 501 ;     If SubsLen = 2 then
E46E             4 502 ;       print character at (start of Substitution String + n + 1)
E46E             4 503 ;     Endif
E46E             4 504 ;   End if

; File #5: C:\Users\Antonio\source\repos\disASM\Z80CodeFiles\Utilities.z80asm

E46E             5 1 ; **********************************************************************************************************************
E46E             5 2 ; **  Utility functions                                                                         by Stephen C Cousins  **
E46E             5 3 ; **********************************************************************************************************************
E46E             5 6 ; Utility: Find start of specified string in bit 7 delimited list
E46E             5 7 ;   On entry: A = String number
E46E             5 8 ;   On exit:  HL = Start of string
E46E             5 9 ;             BC DE IX IY I AF' BC' DE' HL' preserved
E46E             5 10 ; Find string A in bit 7 delimited string list
E46E             5 11 FindStringInList:
E46E C5          5 12 push    bc
E46F 21 7B 03    5 14 Realloc_56          ld      hl, DisString-START-1       ; Start of string list
E472 47          5 15 ld      b, a                        ; Get string number
E473             5 16 NextChar:
E473 23          5 17 inc     hl                          ; Point to next character
E474 CB 7E       5 18 bit     7, (hl)                     ; Start of new string?
E476 28 FB       5 19 jr      z, NextChar                 ; No, so go get next character
E478 10 F9       5 20 djnz    NextChar                    ; Loop back if not the right string
E47A C1          5 22 pop     bc
E47B C9          5 23 ret

; File #6: C:\Users\Antonio\source\repos\disASM\Z80CodeFiles\DisData.z80asm

E47C             6 1 ; **********************************************************************************************************************
E47C             6 2 ; **  Disassembler data                                                                         by Stephen C Cousins  **
E47C             6 3 ; **********************************************************************************************************************
E47C             6 6 ; Disassembler string table: (DisString)
E47C             6 7 ; This contains many string which are not null terminated and have no length 
E47C             6 8 ; value. Instead they are tightly packed with the start of each string 
E47C             6 9 ; indicated by the first character having bit 7 set.
E47C             6 10 DisString:
E47C 80          6 11 DEFB    $80                         ; String $01 = 
E47D EE          6 12 DEFB    $80+'n'                     ; String $02 = n
E47E A8          6 13 DEFB    $80+'('
E47F 6E 29       6 14 DEFM    "n)"                        ; String $03 = (n)
E481 EE 6E       6 15 DEFB    $80+'n','n'                 ; String $04 = nn
E483 A8          6 16 DEFB    $80+'('
E484 6E 6E 29    6 17 DEFM    "nn)"                       ; String $05 = (nn)
E487 F2          6 18 DEFB    $80+'r'                     ; String $06 = r
E488 F2 32       6 19 DEFB    $80+'r','2'                 ; String $07 = r2
E48A E4 64       6 20 DEFB    $80+'d','d'                 ; String $08 = dd
E48C F1 71       6 21 DEFB    $80+'q','q'                 ; String $09 = qq
E48E E3          6 22 DEFB    $80+'c'                     ; String $0A = c
E48F E3 63       6 23 DEFB    $80+'c','c'                 ; String $0B = cc
E491 F4          6 24 DEFB    $80+'t'                     ; String $0C = t
E492 E2          6 25 DEFB    $80+'b'                     ; String $0D = b
E493 C2          6 26 DEFB    $80+'B'
E494 43 44 45 48 6 27 DEFM    "CDEHL-A"                   ; String $0E = BCDEHL-A
E498 4C 2D 41    6 27 
E49B C2          6 28 DEFB    $80+'B'
E49C 43 44 45 2A 6 29 DEFM    "CDE**SP"                   ; String $0F = BCDE**SP
E4A0 2A 53 50    6 29 
E4A3 C2          6 30 DEFB    $80+'B'
E4A4 43 44 45 2A 6 31 DEFM    "CDE**AF"                   ; String $10 = BCDE**AF
E4A8 2A 41 46    6 31 
E4AB CE          6 32 DEFB    $80+'N'
E4AC 5A 5A 2E 4E 6 33 DEFM    "ZZ.NCC."                   ; String $11 = NZZ.NCC.
E4B0 43 43 2E    6 33 
E4B3 CE          6 34 DEFB    $80+'N'
E4B4 5A 5A 2E 4E 6 35 DEFM    "ZZ.NCC.POPEP.M."           ; String $12 = NZZ.NCC.POPEP.M.
E4B8 43 43 2E 50 6 35 
E4BC 4F 50 45 50 6 35 
E4C0 2E 4D 2E    6 35 
E4C3 B0          6 36 DEFB    $80+'0'
E4C4 30 30 38 31 6 37 DEFM    "008162432404856"           ; String $13 = 0008101820283038
E4C8 36 32 34 33 6 37 
E4CC 32 34 30 34 6 37 
E4D0 38 35 36    6 37 
E4D3 B0          6 38 DEFB    $80+'0'
E4D4 31 32 33 34 6 39 DEFM    "1234567"                   ; String $14 = 01234567
E4D8 35 36 37    6 39 
E4DB A8          6 40 DEFB    $80+'('
E4DC 48 4C 29    6 41 DEFM    "HL)"                       ; String $15 = (HL)
E4DF A8          6 42 DEFB    $80+'('
E4E0 49 58 2B    6 43 DEFM    "IX+"                       ; String $16 = (IX+
E4E3 A8          6 44 DEFB    $80+'('
E4E4 49 59 2B    6 45 DEFM    "IY+"                       ; String $17 = (IY+
E4E7 C8 4C       6 46 DEFB    $80+'H','L'                 ; String $18 = HL
E4E9 C9 58       6 47 DEFB    $80+'I','X'                 ; String $19 = IX
E4EB C9 59       6 48 DEFB    $80+'I','Y'                 ; String $1A = IY
E4ED CA 52       6 49 DEFB    $80+'J','R'                 ; String $1B = JR
E4EF C4          6 50 DEFB    $80+'D'
E4F0 4A 4E 5A    6 51 DEFM    "JNZ"                       ; String $1C = DJNZ
E4F3 D2          6 52 DEFB    $80+'R'
E4F4 53 54       6 53 DEFM    "ST"                        ; String $1D = RST
E4F6 CA 50       6 54 DEFB    $80+'J','P'                 ; String $1E = JP
E4F8 C3          6 55 DEFB    $80+'C'
E4F9 41 4C 4C    6 56 DEFM    "ALL"                       ; String $1F = CALL
E4FC D2          6 57 DEFB    $80+'R'
E4FD 45 54       6 58 DEFM    "ET"                        ; String $20 = RET
E4FF D2          6 59 DEFB    $80+'R'
E500 45 54 49    6 60 DEFM    "ETI"                       ; String $21 = RETI
E503 D2          6 61 DEFB    $80+'R'
E504 45 54 4E    6 62 DEFM    "ETN"                       ; String $22 = RETN
E507 C1          6 63 DEFB    $80+'A'                     ; String $23 = A
E508 A8          6 64 DEFB    $80+'('
E509 53 50 29    6 65 DEFM    "SP)"                       ; String $24 = (SP)
E50C C1 46       6 66 DEFB    $80+'A','F'                 ; String $25 = AF
E50E C4 45       6 67 DEFB    $80+'D','E'                 ; String $26 = DE
E510 B0          6 68 DEFB    $80+'0'                     ; String $27 = 0
E511 B1          6 69 DEFB    $80+'1'                     ; String $28 = 1
E512 B2          6 70 DEFB    $80+'2'                     ; String $29 = 2
E513 A8          6 71 DEFB    $80+'('
E514 42 43 29    6 72 DEFM    "BC)"                       ; String $2A = (BC)
E517 A8          6 73 DEFB    $80+'('
E518 44 45 29    6 74 DEFM    "DE)"                       ; String $2B = (DE)
E51B D3 50       6 75 DEFB    $80+'S','P'                 ; String $2C = SP
E51D C9          6 76 DEFB    $80+'I'                     ; String $2D = I
E51E D2          6 77 DEFB    $80+'R'                     ; String $2E = R
E51F A8          6 78 DEFB    $80+'('
E520 43 29       6 79 DEFM    "C)"                        ; String $2F = (C)
E522 C1          6 80 DEFB    $80+'A'
E523 46 27       6 81 DEFM    "F'"                        ; String $30 = AF'
E525 C1          6 82 DEFB    $80+'A'
E526 44 43       6 83 DEFM    "DC"                        ; String $31 = ADC
E528 C1          6 84 DEFB    $80+'A'
E529 44 44       6 85 DEFM    "DD"                        ; String $32 = ADD
E52B C1          6 86 DEFB    $80+'A'
E52C 4E 44       6 87 DEFM    "ND"                        ; String $33 = AND
E52E C2          6 88 DEFB    $80+'B'
E52F 49 54       6 89 DEFM    "IT"                        ; String $34 = BIT
E531 C3          6 90 DEFB    $80+'C'
E532 43 46       6 91 DEFM    "CF"                        ; String $35 = CCF
E534 C3          6 92 DEFB    $80+'C'
E535 50          6 93 DEFM    "P"                         ; String $36 = CP
E536 C3          6 94 DEFB    $80+'C'
E537 50 44       6 95 DEFM    "PD"                        ; String $37 = CPD
E539 C3          6 96 DEFB    $80+'C'
E53A 50 44 52    6 97 DEFM    "PDR"                       ; String $38 = CPDR
E53D C3          6 98 DEFB    $80+'C'
E53E 50 49       6 99 DEFM    "PI"                        ; String $39 = CPI
E540 C3          6 100 DEFB    $80+'C'
E541 50 49 52    6 101 DEFM    "PIR"                       ; String $3A = CPIR
E544 C3          6 102 DEFB    $80+'C'
E545 50 4C       6 103 DEFM    "PL"                        ; String $3B = CPL
E547 C4          6 104 DEFB    $80+'D'
E548 41 41       6 105 DEFM    "AA"                        ; String $3C = DAA
E54A C4          6 106 DEFB    $80+'D'
E54B 45 43       6 107 DEFM    "EC"                        ; String $3D = DEC
E54D C4          6 108 DEFB    $80+'D'
E54E 49          6 109 DEFM    "I"                         ; String $3E = DI
E54F C5          6 110 DEFB    $80+'E'
E550 49          6 111 DEFM    "I"                         ; String $3F = EI
E551 C5          6 112 DEFB    $80+'E'
E552 58          6 113 DEFM    "X"                         ; String $40 = EX
E553 C5          6 114 DEFB    $80+'E'
E554 58 58       6 115 DEFM    "XX"                        ; String $41 = EXX
E556 C8          6 116 DEFB    $80+'H'
E557 41 4C 54    6 117 DEFM    "ALT"                       ; String $42 = HALT
E55A C9          6 118 DEFB    $80+'I'
E55B 4D          6 119 DEFM    "M"                         ; String $43 = IM
E55C C9          6 120 DEFB    $80+'I'
E55D 4E          6 121 DEFM    "N"                         ; String $44 = IN
E55E C9          6 122 DEFB    $80+'I'
E55F 4E 43       6 123 DEFM    "NC"                        ; String $45 = INC
E561 C9          6 124 DEFB    $80+'I'
E562 4E 44       6 125 DEFM    "ND"                        ; String $46 = IND
E564 C9          6 126 DEFB    $80+'I'
E565 4E 44 52    6 127 DEFM    "NDR"                       ; String $47 = INDR
E568 C9          6 128 DEFB    $80+'I'
E569 4E 49       6 129 DEFM    "NI"                        ; String $48 = INI
E56B C9          6 130 DEFB    $80+'I'
E56C 4E 49 52    6 131 DEFM    "NIR"                       ; String $49 = INIR
E56F CC          6 132 DEFB    $80+'L'
E570 44          6 133 DEFM    "D"                         ; String $4A = LD
E571 CC          6 134 DEFB    $80+'L'
E572 44 44       6 135 DEFM    "DD"                        ; String $4B = LDD
E574 CC          6 136 DEFB    $80+'L'
E575 44 44 52    6 137 DEFM    "DDR"                       ; String $4C = LDDR
E578 CC          6 138 DEFB    $80+'L'
E579 44 49       6 139 DEFM    "DI"                        ; String $4D = LDI
E57B CC          6 140 DEFB    $80+'L'
E57C 44 49 52    6 141 DEFM    "DIR"                       ; String $4E = LDIR
E57F CE          6 142 DEFB    $80+'N'
E580 45 47       6 143 DEFM    "EG"                        ; String $4F = NEG
E582 CE          6 144 DEFB    $80+'N'
E583 4F 50       6 145 DEFM    "OP"                        ; String $50 = NOP
E585 CF          6 146 DEFB    $80+'O'
E586 52          6 147 DEFM    "R"                         ; String $51 = OR
E587 CF          6 148 DEFB    $80+'O'
E588 54 44 52    6 149 DEFM    "TDR"                       ; String $52 = OTDR
E58B CF          6 150 DEFB    $80+'O'
E58C 54 49 52    6 151 DEFM    "TIR"                       ; String $53 = OTIR
E58F CF          6 152 DEFB    $80+'O'
E590 55 54       6 153 DEFM    "UT"                        ; String $54 = OUT
E592 CF          6 154 DEFB    $80+'O'
E593 55 54 44    6 155 DEFM    "UTD"                       ; String $55 = OUTD
E596 CF          6 156 DEFB    $80+'O'
E597 55 54 49    6 157 DEFM    "UTI"                       ; String $56 = OUTI
E59A D0          6 158 DEFB    $80+'P'
E59B 4F 50       6 159 DEFM    "OP"                        ; String $57 = POP
E59D D0          6 160 DEFB    $80+'P'
E59E 55 53 48    6 161 DEFM    "USH"                       ; String $58 = PUSH
E5A1 D2          6 162 DEFB    $80+'R'
E5A2 45 53       6 163 DEFM    "ES"                        ; String $59 = RES
E5A4 D2          6 164 DEFB    $80+'R'
E5A5 4C          6 165 DEFM    "L"                         ; String $5A = RL
E5A6 D2          6 166 DEFB    $80+'R'
E5A7 4C 41       6 167 DEFM    "LA"                        ; String $5B = RLA
E5A9 D2          6 168 DEFB    $80+'R'
E5AA 4C 43       6 169 DEFM    "LC"                        ; String $5C = RLC
E5AC D2          6 170 DEFB    $80+'R'
E5AD 4C 43 41    6 171 DEFM    "LCA"                       ; String $5D = RLCA
E5B0 D2          6 172 DEFB    $80+'R'
E5B1 4C 44       6 173 DEFM    "LD"                        ; String $5E = RLD
E5B3 D2          6 174 DEFB    $80+'R'
E5B4 52          6 175 DEFM    "R"                         ; String $5F = RR
E5B5 D2          6 176 DEFB    $80+'R'
E5B6 52 41       6 177 DEFM    "RA"                        ; String $60 = RRA
E5B8 D2          6 178 DEFB    $80+'R'
E5B9 52 43       6 179 DEFM    "RC"                        ; String $61 = RRC
E5BB D2          6 180 DEFB    $80+'R'
E5BC 52 43 41    6 181 DEFM    "RCA"                       ; String $62 = RRCA
E5BF D2          6 182 DEFB    $80+'R'
E5C0 52 44       6 183 DEFM    "RD"                        ; String $63 = RRD
E5C2 D3          6 184 DEFB    $80+'S'
E5C3 42 43       6 185 DEFM    "BC"                        ; String $64 = SBC
E5C5 D3          6 186 DEFB    $80+'S'
E5C6 43 46       6 187 DEFM    "CF"                        ; String $65 = SCF
E5C8 D3          6 188 DEFB    $80+'S'
E5C9 45 54       6 189 DEFM    "ET"                        ; String $66 = SET
E5CB D3          6 190 DEFB    $80+'S'
E5CC 4C 41       6 191 DEFM    "LA"                        ; String $67 = SLA
E5CE D3          6 192 DEFB    $80+'S'
E5CF 4C 4C       6 193 DEFM    "LL"                        ; String $68 = SLL
E5D1 D3          6 194 DEFB    $80+'S'
E5D2 52 41       6 195 DEFM    "RA"                        ; String $69 = SRA
E5D4 D3          6 196 DEFB    $80+'S'
E5D5 52 4C       6 197 DEFM    "RL"                        ; String $6A = SRL
E5D7 D3          6 198 DEFB    $80+'S'
E5D8 55 42       6 199 DEFM    "UB"                        ; String $6B = SUB
E5DA D8          6 200 DEFB    $80+'X'
E5DB 4F 52       6 201 DEFM    "OR"                        ; String $6C = XOR
E5DD BF          6 202 DEFB    $80+'?'
E5DE 3F 3F 3F    6 203 DEFM    "???"                       ; String $6D = ????
E5E1 C8          6 204 DEFB    $80+'H'                     ; String $6E = H
E5E2 C9          6 205 DEFB    $80+'I'
E5E3 58 48       6 206 DEFM    "XH"                        ; String $6F = IXH
E5E5 C9          6 207 DEFB    $80+'I'
E5E6 59 48       6 208 DEFM    "YH"                        ; String $70 = IYH
E5E8 CC          6 209 DEFB    $80+'L'                     ; String $71 = L
E5E9 C9          6 210 DEFB    $80+'I'
E5EA 58 4C       6 211 DEFM    "XL"                        ; String $72 = IXL
E5EC C9          6 212 DEFB    $80+'I'
E5ED 59 4C       6 213 DEFM    "YL"                        ; String $73 = IYL
E5EF 80          6 214 DEFB    $80
E5F0             6 217 ; Instruction table: (DisInst)
E5F0             6 218 ; The instruction table definition of the processor's instruction set.
E5F0             6 219 ; Each instruction is described by 5 bytes:
E5F0             6 220 ;    Byte 0:  Opcode value
E5F0             6 221 ;    Byte 1:  Opcode mask
E5F0             6 222 ;    Byte 2:  Operation string number
E5F0             6 223 ;    Byte 3:  Operand #1 string number, plus bits 6-7 define precode
E5F0             6 224 ;    Byte 4:  Operand #2 string number
E5F0             6 225 ; The precode values code in bits 6-7 are:
E5F0             6 226 ;    00xx xxxx = No precode
E5F0             6 227 ;    10xx xxxx = Precode 0xCB
E5F0             6 228 ;    11xx xxxx = Precode 0xED
E5F0             6 229 ; Precodes are used by the processor's extended instructions
E5F0             6 230 DisInst:
E5F0 88 F8 31 23 6 231 DEFB    $88, $F8, $31, $23, $07     ; Opcode: $88 - ADC  A   ,r2
E5F4 07          6 231 
E5F5 CE FF 31 23 6 232 DEFB    $CE, $FF, $31, $23, $02     ; Opcode: $CE - ADC  A   ,n
E5F9 02          6 232 
E5FA 4A CF 31 D8 6 233 DEFB    $4A, $CF, $31, $D8, $08     ; Opcode: $4A - ADC  HL  ,dd
E5FE 08          6 233 
E5FF 80 F8 32 23 6 234 DEFB    $80, $F8, $32, $23, $07     ; Opcode: $80 - ADD  A   ,r2
E603 07          6 234 
E604 C6 FF 32 23 6 235 DEFB    $C6, $FF, $32, $23, $02     ; Opcode: $C6 - ADD  A   ,n
E608 02          6 235 
E609 09 CF 32 18 6 236 DEFB    $09, $CF, $32, $18, $08     ; Opcode: $09 - ADD  HL  ,dd
E60D 08          6 236 
E60E A0 F8 33 07 6 237 DEFB    $A0, $F8, $33, $07, $01     ; Opcode: $A0 - AND  r2  ,
E612 01          6 237 
E613 E6 FF 33 02 6 238 DEFB    $E6, $FF, $33, $02, $01     ; Opcode: $E6 - AND  n   ,
E617 01          6 238 
E618 40 C0 34 8D 6 239 DEFB    $40, $C0, $34, $8D, $07     ; Opcode: $40 - BIT  b   ,r2
E61C 07          6 239 
E61D C4 C7 1F 0B 6 240 DEFB    $C4, $C7, $1F, $0B, $04     ; Opcode: $C4 - CALL cc  ,nn
E621 04          6 240 
E622 CD FF 1F 04 6 241 DEFB    $CD, $FF, $1F, $04, $01     ; Opcode: $CD - CALL nn  ,
E626 01          6 241 
E627 3F FF 35 01 6 242 DEFB    $3F, $FF, $35, $01, $01     ; Opcode: $3F - CCF      ,
E62B 01          6 242 
E62C B8 F8 36 07 6 243 DEFB    $B8, $F8, $36, $07, $01     ; Opcode: $B8 - CP   r2  ,
E630 01          6 243 
E631 FE FF 36 02 6 244 DEFB    $FE, $FF, $36, $02, $01     ; Opcode: $FE - CP   n   ,
E635 01          6 244 
E636 A9 FF 37 C1 6 245 DEFB    $A9, $FF, $37, $C1, $01     ; Opcode: $A9 - CPD      ,
E63A 01          6 245 
E63B B9 FF 38 C1 6 246 DEFB    $B9, $FF, $38, $C1, $01     ; Opcode: $B9 - CPDR     ,
E63F 01          6 246 
E640 A1 FF 39 C1 6 247 DEFB    $A1, $FF, $39, $C1, $01     ; Opcode: $A1 - CPI      ,
E644 01          6 247 
E645 B1 FF 3A C1 6 248 DEFB    $B1, $FF, $3A, $C1, $01     ; Opcode: $B1 - CPIR     ,
E649 01          6 248 
E64A 2F FF 3B 01 6 249 DEFB    $2F, $FF, $3B, $01, $01     ; Opcode: $2F - CPL      ,
E64E 01          6 249 
E64F 27 FF 3C 01 6 250 DEFB    $27, $FF, $3C, $01, $01     ; Opcode: $27 - DAA      ,
E653 01          6 250 
E654 0B CF 3D 08 6 251 DEFB    $0B, $CF, $3D, $08, $01     ; Opcode: $0B - DEC  dd  ,
E658 01          6 251 
E659 05 C7 3D 06 6 252 DEFB    $05, $C7, $3D, $06, $01     ; Opcode: $05 - DEC  r   ,
E65D 01          6 252 
E65E F3 FF 3E 01 6 253 DEFB    $F3, $FF, $3E, $01, $01     ; Opcode: $F3 - DI       ,
E662 01          6 253 
E663 10 FF 1C 02 6 254 DEFB    $10, $FF, $1C, $02, $01     ; Opcode: $10 - DJNZ n   ,
E667 01          6 254 
E668 FB FF 3F 01 6 255 DEFB    $FB, $FF, $3F, $01, $01     ; Opcode: $FB - EI       ,
E66C 01          6 255 
E66D E3 FF 40 24 6 256 DEFB    $E3, $FF, $40, $24, $18     ; Opcode: $E3 - EX   (SP),HL
E671 18          6 256 
E672 08 FF 40 25 6 257 DEFB    $08, $FF, $40, $25, $30     ; Opcode: $08 - EX   AF  ,AF'
E676 30          6 257 
E677 EB FF 40 26 6 258 DEFB    $EB, $FF, $40, $26, $18     ; Opcode: $EB - EX   DE  ,HL
E67B 18          6 258 
E67C D9 FF 41 01 6 259 DEFB    $D9, $FF, $41, $01, $01     ; Opcode: $D9 - EXX      ,
E680 01          6 259 
E681 76 FF 42 01 6 260 DEFB    $76, $FF, $42, $01, $01     ; Opcode: $76 - HALT     ,
E685 01          6 260 
E686 46 FF 43 E7 6 261 DEFB    $46, $FF, $43, $E7, $01     ; Opcode: $46 - IM   0   ,
E68A 01          6 261 
E68B 56 FF 43 E8 6 262 DEFB    $56, $FF, $43, $E8, $01     ; Opcode: $56 - IM   1   ,
E68F 01          6 262 
E690 5E FF 43 E9 6 263 DEFB    $5E, $FF, $43, $E9, $01     ; Opcode: $5E - IM   2   ,
E694 01          6 263 
E695 40 C7 44 C6 6 264 DEFB    $40, $C7, $44, $C6, $2F     ; Opcode: $40 - IN   r   ,(C)
E699 2F          6 264 
E69A DB FF 44 23 6 265 DEFB    $DB, $FF, $44, $23, $03     ; Opcode: $DB - IN   A   ,(n)
E69E 03          6 265 
E69F 03 CF 45 08 6 266 DEFB    $03, $CF, $45, $08, $01     ; Opcode: $03 - INC  dd  ,
E6A3 01          6 266 
E6A4 04 C7 45 06 6 267 DEFB    $04, $C7, $45, $06, $01     ; Opcode: $04 - INC  r   ,
E6A8 01          6 267 
E6A9 AA FF 46 C1 6 268 DEFB    $AA, $FF, $46, $C1, $01     ; Opcode: $AA - IND      ,
E6AD 01          6 268 
E6AE BA FF 47 C1 6 269 DEFB    $BA, $FF, $47, $C1, $01     ; Opcode: $BA - INDR     ,
E6B2 01          6 269 
E6B3 A2 FF 48 C1 6 270 DEFB    $A2, $FF, $48, $C1, $01     ; Opcode: $A2 - INI      ,
E6B7 01          6 270 
E6B8 B2 FF 49 C1 6 271 DEFB    $B2, $FF, $49, $C1, $01     ; Opcode: $B2 - INIR     ,
E6BC 01          6 271 
E6BD E9 FF 1E 15 6 272 DEFB    $E9, $FF, $1E, $15, $01     ; Opcode: $E9 - JP   (HL),
E6C1 01          6 272 
E6C2 C2 C7 1E 0B 6 273 DEFB    $C2, $C7, $1E, $0B, $04     ; Opcode: $C2 - JP   cc  ,nn
E6C6 04          6 273 
E6C7 C3 FF 1E 04 6 274 DEFB    $C3, $FF, $1E, $04, $01     ; Opcode: $C3 - JP   nn  ,
E6CB 01          6 274 
E6CC 20 E7 1B 0A 6 275 DEFB    $20, $E7, $1B, $0A, $02     ; Opcode: $20 - JR   c   ,n
E6D0 02          6 275 
E6D1 18 FF 1B 02 6 276 DEFB    $18, $FF, $1B, $02, $01     ; Opcode: $18 - JR   n   ,
E6D5 01          6 276 
E6D6 40 C0 4A 06 6 277 DEFB    $40, $C0, $4A, $06, $07     ; Opcode: $40 - LD   r   ,r2
E6DA 07          6 277 
E6DB 02 FF 4A 2A 6 278 DEFB    $02, $FF, $4A, $2A, $23     ; Opcode: $02 - LD   (BC),A
E6DF 23          6 278 
E6E0 12 FF 4A 2B 6 279 DEFB    $12, $FF, $4A, $2B, $23     ; Opcode: $12 - LD   (DE),A
E6E4 23          6 279 
E6E5 32 FF 4A 05 6 280 DEFB    $32, $FF, $4A, $05, $23     ; Opcode: $32 - LD   (nn),A
E6E9 23          6 280 
E6EA 22 FF 4A 05 6 281 DEFB    $22, $FF, $4A, $05, $18     ; Opcode: $22 - LD   (nn),HL
E6EE 18          6 281 
E6EF 43 CF 4A C5 6 282 DEFB    $43, $CF, $4A, $C5, $08     ; Opcode: $43 - LD   (nn),dd
E6F3 08          6 282 
E6F4 0A FF 4A 23 6 283 DEFB    $0A, $FF, $4A, $23, $2A     ; Opcode: $0A - LD   A   ,(BC)
E6F8 2A          6 283 
E6F9 1A FF 4A 23 6 284 DEFB    $1A, $FF, $4A, $23, $2B     ; Opcode: $1A - LD   A   ,(DE)
E6FD 2B          6 284 
E6FE 3A FF 4A 23 6 285 DEFB    $3A, $FF, $4A, $23, $05     ; Opcode: $3A - LD   A   ,(nn)
E702 05          6 285 
E703 2A FF 4A 18 6 286 DEFB    $2A, $FF, $4A, $18, $05     ; Opcode: $2A - LD   HL  ,(nn)
E707 05          6 286 
E708 F9 FF 4A 2C 6 287 DEFB    $F9, $FF, $4A, $2C, $18     ; Opcode: $F9 - LD   SP  ,HL
E70C 18          6 287 
E70D 01 CF 4A 08 6 288 DEFB    $01, $CF, $4A, $08, $04     ; Opcode: $01 - LD   dd  ,nn
E711 04          6 288 
E712 4B CF 4A C8 6 289 DEFB    $4B, $CF, $4A, $C8, $05     ; Opcode: $4B - LD   dd  ,(nn)
E716 05          6 289 
E717 57 FF 4A E3 6 290 DEFB    $57, $FF, $4A, $E3, $2D     ; Opcode: $57 - LD   A   ,I
E71B 2D          6 290 
E71C 5F FF 4A E3 6 291 DEFB    $5F, $FF, $4A, $E3, $2E     ; Opcode: $5F - LD   A   ,R
E720 2E          6 291 
E721 47 FF 4A ED 6 292 DEFB    $47, $FF, $4A, $ED, $23     ; Opcode: $47 - LD   I   ,A
E725 23          6 292 
E726 4F FF 4A EE 6 293 DEFB    $4F, $FF, $4A, $EE, $23     ; Opcode: $4F - LD   R   ,A
E72A 23          6 293 
E72B 06 C7 4A 06 6 294 DEFB    $06, $C7, $4A, $06, $02     ; Opcode: $06 - LD   r   ,n
E72F 02          6 294 
E730 A8 FF 4B C1 6 295 DEFB    $A8, $FF, $4B, $C1, $01     ; Opcode: $A8 - LDD      ,
E734 01          6 295 
E735 B8 FF 4C C1 6 296 DEFB    $B8, $FF, $4C, $C1, $01     ; Opcode: $B8 - LDDR     ,
E739 01          6 296 
E73A A0 FF 4D C1 6 297 DEFB    $A0, $FF, $4D, $C1, $01     ; Opcode: $A0 - LDI      ,
E73E 01          6 297 
E73F B0 FF 4E C1 6 298 DEFB    $B0, $FF, $4E, $C1, $01     ; Opcode: $B0 - LDIR     ,
E743 01          6 298 
E744 44 FF 4F C1 6 299 DEFB    $44, $FF, $4F, $C1, $01     ; Opcode: $44 - NEG      ,
E748 01          6 299 
E749 00 FF 50 01 6 300 DEFB    $00, $FF, $50, $01, $01     ; Opcode: $00 - NOP      ,
E74D 01          6 300 
E74E B0 F8 51 07 6 301 DEFB    $B0, $F8, $51, $07, $01     ; Opcode: $B0 - OR   r2  ,
E752 01          6 301 
E753 F6 FF 51 02 6 302 DEFB    $F6, $FF, $51, $02, $01     ; Opcode: $F6 - OR   n   ,
E757 01          6 302 
E758 BB FF 52 C1 6 303 DEFB    $BB, $FF, $52, $C1, $01     ; Opcode: $BB - OTDR     ,
E75C 01          6 303 
E75D B3 FF 53 C1 6 304 DEFB    $B3, $FF, $53, $C1, $01     ; Opcode: $B3 - OTIR     ,
E761 01          6 304 
E762 41 C7 54 EF 6 305 DEFB    $41, $C7, $54, $EF, $06     ; Opcode: $41 - OUT  (C) ,r
E766 06          6 305 
E767 D3 FF 54 03 6 306 DEFB    $D3, $FF, $54, $03, $23     ; Opcode: $D3 - OUT  (n) ,A
E76B 23          6 306 
E76C AB FF 55 C1 6 307 DEFB    $AB, $FF, $55, $C1, $01     ; Opcode: $AB - OUTD     ,
E770 01          6 307 
E771 A3 FF 56 C1 6 308 DEFB    $A3, $FF, $56, $C1, $01     ; Opcode: $A3 - OUTI     ,
E775 01          6 308 
E776 C1 CF 57 09 6 309 DEFB    $C1, $CF, $57, $09, $01     ; Opcode: $C1 - POP  qq  ,
E77A 01          6 309 
E77B C5 CF 58 09 6 310 DEFB    $C5, $CF, $58, $09, $01     ; Opcode: $C5 - PUSH qq  ,
E77F 01          6 310 
E780 80 C0 59 8D 6 311 DEFB    $80, $C0, $59, $8D, $07     ; Opcode: $80 - RES  b   ,r2
E784 07          6 311 
E785 C9 FF 20 01 6 312 DEFB    $C9, $FF, $20, $01, $01     ; Opcode: $C9 - RET      ,
E789 01          6 312 
E78A C0 C7 20 0B 6 313 DEFB    $C0, $C7, $20, $0B, $01     ; Opcode: $C0 - RET  cc  ,
E78E 01          6 313 
E78F 4D FF 21 C1 6 314 DEFB    $4D, $FF, $21, $C1, $01     ; Opcode: $4D - RETI     ,
E793 01          6 314 
E794 45 FF 22 C1 6 315 DEFB    $45, $FF, $22, $C1, $01     ; Opcode: $45 - RETN     ,
E798 01          6 315 
E799 10 F8 5A 87 6 316 DEFB    $10, $F8, $5A, $87, $01     ; Opcode: $10 - RL   r2  ,
E79D 01          6 316 
E79E 17 FF 5B 01 6 317 DEFB    $17, $FF, $5B, $01, $01     ; Opcode: $17 - RLA      ,
E7A2 01          6 317 
E7A3 00 F8 5C 87 6 318 DEFB    $00, $F8, $5C, $87, $01     ; Opcode: $00 - RLC  r2  ,
E7A7 01          6 318 
E7A8 07 FF 5D 01 6 319 DEFB    $07, $FF, $5D, $01, $01     ; Opcode: $07 - RLCA     ,
E7AC 01          6 319 
E7AD 6F FF 5E C1 6 320 DEFB    $6F, $FF, $5E, $C1, $01     ; Opcode: $6F - RLD      ,
E7B1 01          6 320 
E7B2 18 F8 5F 87 6 321 DEFB    $18, $F8, $5F, $87, $01     ; Opcode: $18 - RR   r2  ,
E7B6 01          6 321 
E7B7 1F FF 60 01 6 322 DEFB    $1F, $FF, $60, $01, $01     ; Opcode: $1F - RRA      ,
E7BB 01          6 322 
E7BC 08 F8 61 87 6 323 DEFB    $08, $F8, $61, $87, $01     ; Opcode: $08 - RRC  r2  ,
E7C0 01          6 323 
E7C1 0F FF 62 01 6 324 DEFB    $0F, $FF, $62, $01, $01     ; Opcode: $0F - RRCA     ,
E7C5 01          6 324 
E7C6 67 FF 63 C1 6 325 DEFB    $67, $FF, $63, $C1, $01     ; Opcode: $67 - RRD      ,
E7CA 01          6 325 
E7CB C7 C7 1D 0C 6 326 DEFB    $C7, $C7, $1D, $0C, $01     ; Opcode: $C7 - RST  t   ,
E7CF 01          6 326 
E7D0 98 F8 64 23 6 327 DEFB    $98, $F8, $64, $23, $07     ; Opcode: $98 - SBC  A   ,r2
E7D4 07          6 327 
E7D5 DE FF 64 23 6 328 DEFB    $DE, $FF, $64, $23, $02     ; Opcode: $DE - SBC  A   ,n
E7D9 02          6 328 
E7DA 42 CF 64 D8 6 329 DEFB    $42, $CF, $64, $D8, $08     ; Opcode: $42 - SBC  HL  ,dd
E7DE 08          6 329 
E7DF 37 FF 65 01 6 330 DEFB    $37, $FF, $65, $01, $01     ; Opcode: $37 - SCF      ,
E7E3 01          6 330 
E7E4 C0 C0 66 8D 6 331 DEFB    $C0, $C0, $66, $8D, $07     ; Opcode: $C0 - SET  b   ,r2
E7E8 07          6 331 
E7E9 20 F8 67 87 6 332 DEFB    $20, $F8, $67, $87, $01     ; Opcode: $20 - SLA  r2  ,
E7ED 01          6 332 
E7EE 30 F8 68 87 6 333 DEFB    $30, $F8, $68, $87, $01     ; Opcode: $30 - SLL  r2  ,
E7F2 01          6 333 
E7F3 28 F8 69 87 6 334 DEFB    $28, $F8, $69, $87, $01     ; Opcode: $28 - SRA  r2  ,
E7F7 01          6 334 
E7F8 38 F8 6A 87 6 335 DEFB    $38, $F8, $6A, $87, $01     ; Opcode: $38 - SRL  r2  ,
E7FC 01          6 335 
E7FD 90 F8 6B 07 6 336 DEFB    $90, $F8, $6B, $07, $01     ; Opcode: $90 - SUB  r2  ,
E801 01          6 336 
E802 D6 FF 6B 02 6 337 DEFB    $D6, $FF, $6B, $02, $01     ; Opcode: $D6 - SUB  n   ,
E806 01          6 337 
E807 A8 F8 6C 07 6 338 DEFB    $A8, $F8, $6C, $07, $01     ; Opcode: $A8 - XOR  r2  ,
E80B 01          6 338 
E80C EE FF 6C 02 6 339 DEFB    $EE, $FF, $6C, $02, $01     ; Opcode: $EE - XOR  n   ,
E810 01          6 339 
E811 00 00 6D 01 6 340 DEFB    $00, $00, $6D, $01, $01     ; Opcode: $00 - ????     ,
E815 01          6 340 
E816 00 00 6D C1 6 341 DEFB    $00, $00, $6D, $C1, $01     ; Opcode: $00 - ????     ,
E81A 01          6 341 
E81B             6 344 ; Operand table:
E81B             6 345 ;   Index into table is the operand string number 1 to 13)
E81B             6 346 ;   Contents: Substitution string number, function bits BIILMM
E81B             6 347 ;
E81B             6 348 ; Op  String  Offset  Bracket  Immediate  Substitue     subsLen  subsMask  ->  BIILMM
E81B             6 349 ;  1  =""     +0      No       No   (00)  No                n/a  n/a           000000
E81B             6 350 ;  2  ="n"    +1      No       Byte (10)  No                n/a  n/a           010000
E81B             6 351 ;  3  ="(n)"  +1      Yes      Byte (10)  No                n/a  n/a           110000
E81B             6 352 ;  4  ="nn"   +2      No       Word (11)  No                n/a  n/a           011000
E81B             6 353 ;  5  ="(nn)" +2      Yes      Word (11)  No                n/a  n/a           111000
E81B             6 354 ;  6  ="r"    +0      No       No   (00)  "BCDEHL-A"          1  0x38 (11)     000011
E81B             6 355 ;  7  ="r2"   +0      No       No   (00)  "BCDEHL-A"          1  0x07 (00)     000000
E81B             6 356 ;  8  ="dd"   +0      No       No   (00)  "BCDEHLSP"          2  0x30 (10)     000110
E81B             6 357 ;  9  ="qq"   +0      No       No   (00)  "BCDEHLAF"          2  0x30 (10)     000110
E81B             6 358 ; 10  ="c"    +0      No       No   (00)  "NZZ NCC "          2  0x18 (01)     000101
E81B             6 359 ; 11  ="cc"   +0      No       No   (00)  "NZZ NCC POPEP M "  2  0x38 (11)     000111
E81B             6 360 ; 12  ="t"    +0      No       No   (00)  "0008101820283038"  2  0x38 (11)     000111
E81B             6 361 ; 13  ="b"    +0      No       No   (00)  "01234567"          1  0x38 (11)     000011
E81B             6 362 ; Each table entry is coded with the string number plus a byte containing BIILMM bits
E81B             6 363 ; Length bit is hi for strings with two character substitutions
E81B             6 364 DisOperandTable:
E81B 00 00       6 365 DEFB    $00, $00                    ; 0b000000 ;Operand  1 = ""
E81D 00 10       6 366 DEFB    $00, $10                    ; 0b010000 ;Operand  2 = "n"
E81F 00 30       6 367 DEFB    $00, $30                    ; 0b110000 ;Operand  3 = "(n)"
E821 00 18       6 368 DEFB    $00, $18                    ; 0b011000 ;Operand  4 = "nn"
E823 00 38       6 369 DEFB    $00, $38                    ; 0b111000 ;Operand  5 = "(nn)"
E825 0E 03       6 370 DEFB    $0E, $03                    ; 0b000011 ;Operand  6 = "r"
E827 0E 00       6 371 DEFB    $0E, $00                    ; 0b000000 ;Operand  7 = "r2"
E829 0F 06       6 372 DEFB    $0F, $06                    ; 0b000110 ;Operand  8 = "dd"
E82B 10 06       6 373 DEFB    $10, $06                    ; 0b000110 ;Operand  9 = "qq"
E82D 11 05       6 374 DEFB    $11, $05                    ; 0b000101 ;Operand 10 = "c"
E82F 12 07       6 375 DEFB    $12, $07                    ; 0b000111 ;Operand 11 = "cc"
E831 13 07       6 376 DEFB    $13, $07                    ; 0b000111 ;Operand 12 = "t"
E833 14 03       6 377 DEFB    $14, $03                    ; 0b000011 ;Operand 13 = "b"
E835             6 380 ; Mask table
E835             6 381 ; These are the masks used to separate token values such as register "BCDEHL-A"
E835             6 382 ; The index into the table is coded in the two mask bits from the above table.
E835             6 383 DisMaskTable:
E835 07          6 384 DEFB    $07                         ; Mask type 0
E836 18          6 385 DEFB    $18                         ; Mask type 1
E837 30          6 386 DEFB    $30                         ; Mask type 2
E838 38          6 387 DEFB    $38                         ; Mask type 3
E839             6 390 ; **********************************************************************************************************************
E839             6 391 ; **  Added by Antonio Luque for ZX Spectrum disASM                                                                   **
E839             6 392 ; **********************************************************************************************************************
E839             6 394 ; Strings
E839 6D 6F 72 65 6 395 StrMore:            DEFM    "more?"
E83D 3F          6 395 
E83E             6 396 StrLabels:
E83E 66 72 6F 6D 6 397 DEFM    "from:"
E842 3A          6 397 
E843 20 20 74 6F 6 398 DEFM    "  to:"
E847 3A          6 398 
E848             6 401 ; Relative reallocation addresses ** MUST be below StrLabels **
E848             6 402 ; This space is reused for the string buffer and the internal stack
E848             6 403 Realloc_Addrs:
E848             6 404 kStrBuffer:
E848 20 00       6 405 DEFW    Realloc_A-START+1
E84A 23 00       6 406 DEFW    Realloc_B-START+1
E84C 26 00       6 407 DEFW    Realloc_C-START+1
E84E 2E 00       6 408 DEFW    Realloc_1-START+1
E850 33 00       6 409 DEFW    Realloc_2-START+1
E852 36 00       6 410 DEFW    Realloc_3-START+1
E854 4E 00       6 411 DEFW    Realloc_4-START+1
E856 EB 00       6 412 DEFW    Realloc_5-START+1
E858 10 01       6 413 DEFW    Realloc_6-START+1
E85A 22 01       6 414 DEFW    Realloc_7-START+1
E85C 2D 01       6 415 DEFW    Realloc_8-START+1
E85E 3F 01       6 416 DEFW    Realloc_9-START+1
E860 6A 01       6 417 DEFW    Realloc_10-START+1
E862 74 01       6 418 DEFW    Realloc_11-START+1
E864 81 01       6 419 DEFW    Realloc_12-START+1
E866 97 01       6 420 DEFW    Realloc_13-START+1
E868 9C 01       6 421 DEFW    Realloc_14-START+1
E86A A0 01       6 422 DEFW    Realloc_15-START+1
E86C A5 01       6 423 DEFW    Realloc_16-START+1
E86E B8 01       6 424 DEFW    Realloc_17-START+1
E870 CA 01       6 425 DEFW    Realloc_18-START+1
E872 D3 01       6 426 DEFW    Realloc_19-START+1
E874 D8 01       6 427 DEFW    Realloc_20-START+1
E876 DB 01       6 428 DEFW    Realloc_21-START+1
E878 E5 01       6 429 DEFW    Realloc_22-START+1
E87A E8 01       6 430 DEFW    Realloc_23-START+1
E87C EC 01       6 431 DEFW    Realloc_24-START+1
E87E F5 01       6 432 DEFW    Realloc_25-START+1
E880 00 02       6 433 DEFW    Realloc_26-START+1
E882 1B 02       6 434 DEFW    Realloc_27-START+1
E884 1E 02       6 435 DEFW    Realloc_28-START+1
E886 4F 02       6 436 DEFW    Realloc_29-START+1
E888 55 02       6 437 DEFW    Realloc_30-START+1
E88A 60 02       6 438 DEFW    Realloc_31-START+1
E88C 71 02       6 439 DEFW    Realloc_32-START+2          ; ld ix,nn
E88E 75 02       6 440 DEFW    Realloc_33-START+2          ; ld (nn),de
E890 78 02       6 441 DEFW    Realloc_34-START+1
E892 7C 02       6 442 DEFW    Realloc_35-START+1
E894 7F 02       6 443 DEFW    Realloc_36-START+1
E896 88 02       6 444 DEFW    Realloc_37-START+1
E898 8E 02       6 445 DEFW    Realloc_38-START+1
E89A 93 02       6 446 DEFW    Realloc_39-START+1
E89C 98 02       6 447 DEFW    Realloc_40-START+1
E89E 9C 02       6 448 DEFW    Realloc_41-START+1
E8A0 AA 02       6 449 DEFW    Realloc_42-START+1
E8A2 D0 02       6 450 DEFW    Realloc_43-START+1
E8A4 D4 02       6 451 DEFW    Realloc_44-START+1
E8A6 05 03       6 452 DEFW    Realloc_45-START+1
E8A8 09 03       6 453 DEFW    Realloc_46-START+1
E8AA 0E 03       6 454 DEFW    Realloc_47-START+1
E8AC 15 03       6 455 DEFW    Realloc_48-START+1
E8AE 20 03       6 456 DEFW    Realloc_49-START+1
E8B0 27 03       6 457 DEFW    Realloc_50-START+1
E8B2 33 03       6 458 DEFW    Realloc_51-START+1
E8B4 39 03       6 459 DEFW    Realloc_52-START+1
E8B6 4F 03       6 460 DEFW    Realloc_53-START+1
E8B8 52 03       6 461 DEFW    Realloc_54-START+1
E8BA 57 03       6 462 DEFW    Realloc_55-START+1
E8BC 70 03       6 463 DEFW    Realloc_56-START+1
E8BE 00 00       6 464 DEFW    $0000                       ; The stack begins here
E8C0             6 465 END
